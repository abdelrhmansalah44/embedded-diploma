/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "GPIO.h"
#include "EXTI.h"
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int control_register;
int IPSR_register, val;

//flags
uint8_t Irq_flag, TASKA_FLAG, TASKB_FLAG;
extern int _estack;

unsigned int _s_msp = &_estack;
unsigned int _e_msp;

unsigned int _s_psp_taskA;
unsigned int _e_psp_taskA;

unsigned int _s_psp_taskB;
unsigned int _e_psp_taskB;

#define set_psp_reg(address) 		 __asm volatile("mov r0,%0 \n\t MSR PSP,r0 \n\t ": : "r"(address))
#define msp_to_psp_conversion() 	 __asm volatile("MRS r0,CONTROL \n\t mov r1,#0x02 \n\t ORR r0,r0,r1 \n\t MSR CONTROL,r0")
#define psp_to_msp_conversion() 	 __asm volatile("MRS r0,CONTROL \n\t mov r1,#0x05 \n\t AND r0,r0,r1 \n\t MSR CONTROL,r0")
#define os_exceptional_callback()	 __asm volatile("SVC #0X3")

enum cpu_level {
	priviledged, unpriviledged
};

void cpu_access_level(enum cpu_level level) {
	switch (level) {
	case priviledged:

		__asm("MRS r3,CONTROL \n\t"
				" LSR r3,r3,#0x1 \n\t"
				"LSL r3,r3,#0x1 \n\t"
				"MSR CONTROL,r3");

		break;

	case unpriviledged:
		__asm("MRS r3,CONTROL \n\t"
				"ORR r3,r3,#0x1 \n\t"
				"MSR CONTROL,r3");
		break;

	}
}

void SVC_Handler() {
	cpu_access_level(priviledged);
}

void EXTI_irq() {

	//in this ISR there will be an exchange between taskA and taskB

	if (Irq_flag == 0) {
		TASKA_FLAG = 1;
		TASKB_FLAG = 0;
		Irq_flag = 1;

	} else if (Irq_flag == 1) {
		TASKB_FLAG = 1;
		TASKA_FLAG = 0;
		Irq_flag = 0;
	}

}

int taskA(int a, int b, int c) {
	return a + b + c;
}
int taskB(int a, int b, int c, int d) {
	return a + b + c + d;
}

void main_OS() {
	_e_msp = _s_msp - 512;

	_s_psp_taskA = _e_msp - 8;
	_e_psp_taskA = _s_psp_taskA - 100;

	_s_psp_taskB = _e_psp_taskA - 8;
	_e_psp_taskB = _s_psp_taskB - 100;

	while (1) {




		__asm("nop");

		if (TASKA_FLAG == 1) {
			//set psp register = _s_psp_taskA
			set_psp_reg(_s_psp_taskA);

			//convert from msp to psp from CONTROL register
			msp_to_psp_conversion();

			//unpriviledged
			cpu_access_level(unpriviledged);

			TASKA_FLAG = taskA(1, 2, 3);

			os_exceptional_callback();
			psp_to_msp_conversion();

		} else if (TASKB_FLAG == 1) {
			//set psp register = _s_psp_taskB
			set_psp_reg(_s_psp_taskB);

			//convert from msp to psp from CONTROL register
			msp_to_psp_conversion();

			//unpriviledged
			cpu_access_level(unpriviledged);
			TASKB_FLAG = taskB(1, 2, 3, 4);

			os_exceptional_callback();
			psp_to_msp_conversion();
		}

	}

}

int main(void) {
	RCC_GPIOB_CLK_EN();
	RCC_AFIO_CLK_EN();

	EXTI_PinConfig_t EXTI_Config;

	EXTI_Config.EXTI_PIN = EXTI9PB9;
	EXTI_Config.IRQ_EN = EXTI_IRQ_Enable;
	EXTI_Config.Trigger_Case = EXTI_Trigger_RISING;
	EXTI_Config.P_IRQ_CallBack = EXTI_irq;

	MCAL_EXTI_GPIO_init(&EXTI_Config);




	main_OS();
	while (1) {
		if (Irq_flag) {
			Irq_flag = 0;
		} else {

		}
	}
}

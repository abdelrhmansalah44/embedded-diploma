/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "stm32_f103c6_gpio_driver.h"
#include "lcd.h"
#include "keypad.h"


#define ZERO  0x01
#define ONE   0x79
#define TWO   0x24
#define THREE 0x30
#define FOUR  0x4C
#define FIVE  0x12
#define SIX   0x02
#define SEVEN 0x19
#define EIGHT 0x00
#define NINE  0x10







void clock_init();
void delay_(unsigned int x);
void sevensegment_init();

int main(void) {
	clock_init();
	LCD_INIT();

	LCD_WRITE_STRING("   LCD is READY   ");
	delay_(500);
	LCD_clear_screen();

	LCD_WRITE_STRING("SEVEN SEGMANT    is READY");
	delay_(500);
	LCD_clear_screen();

	unsigned char LCD_DISPLAY[11] = { '0', '1', '2', '3', '4', '5', '6', '7','8', '9', '0' };
	unsigned int DISPLAY[11] = { ZERO, ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN,EIGHT, NINE, ZERO };
	for (unsigned char i = 0; i < 11; i++) {
		LCD_WRITE_CHAR(LCD_DISPLAY[i]);
		MCAL_GPIO_WRITE_PORT(GPIOB, DISPLAY[i] << 9); /* write data on to the LED port */

		delay_(100);

	}
	LCD_clear_screen();
	Keypad_init();
	LCD_WRITE_STRING("    KEYPAD_READY   ");
	delay_(500);
	LCD_clear_screen();

	int key_press;
	int count = 0;
	while (1) {

		key_press = Keypad_getkey();
		switch (key_press) {
		case 'N':
			break;
		case '!':
			LCD_clear_screen();
			break;
		default:
			if (count == 16) // check if cursor reach to the end of line 1
					{
				LCD_GOTO_XY(2, 0);
			} else if (count == 32) // check if cursor reach to the end of line 2
					{
				LCD_clear_screen();
				LCD_GOTO_XY(1, 0);
			}
			count++;

			LCD_WRITE_CHAR(key_press);
			break;

		}

	}

}

void sevensegment_init() {

	GPIO_CONFIGURATION pinconfig;

	pinconfig.GPIO_PIN_MODE = GPIO_PUSHPULL_OUTPUT;
	pinconfig.GPIO_OUTPUT_SPEED = GPIO_OUTPUT_10MHz;
	pinconfig.GPIO_PIN_NUMBER = GPIO_PIN9;
	MCAL_GPIO_INIT(GPIOB, &pinconfig);

	pinconfig.GPIO_PIN_MODE = GPIO_PUSHPULL_OUTPUT;
	pinconfig.GPIO_OUTPUT_SPEED = GPIO_OUTPUT_10MHz;
	pinconfig.GPIO_PIN_NUMBER = GPIO_PIN10;
	MCAL_GPIO_INIT(GPIOB, &pinconfig);

	pinconfig.GPIO_PIN_MODE = GPIO_PUSHPULL_OUTPUT;
	pinconfig.GPIO_OUTPUT_SPEED = GPIO_OUTPUT_10MHz;
	pinconfig.GPIO_PIN_NUMBER = GPIO_PIN11;
	MCAL_GPIO_INIT(GPIOB, &pinconfig);

	pinconfig.GPIO_PIN_MODE = GPIO_PUSHPULL_OUTPUT;
	pinconfig.GPIO_OUTPUT_SPEED = GPIO_OUTPUT_10MHz;
	pinconfig.GPIO_PIN_NUMBER = GPIO_PIN12;
	MCAL_GPIO_INIT(GPIOB, &pinconfig);

	pinconfig.GPIO_PIN_MODE = GPIO_PUSHPULL_OUTPUT;
	pinconfig.GPIO_OUTPUT_SPEED = GPIO_OUTPUT_10MHz;
	pinconfig.GPIO_PIN_NUMBER = GPIO_PIN13;
	MCAL_GPIO_INIT(GPIOB, &pinconfig);

	pinconfig.GPIO_PIN_MODE = GPIO_PUSHPULL_OUTPUT;
	pinconfig.GPIO_OUTPUT_SPEED = GPIO_OUTPUT_10MHz;
	pinconfig.GPIO_PIN_NUMBER = GPIO_PIN14;
	MCAL_GPIO_INIT(GPIOB, &pinconfig);

	pinconfig.GPIO_PIN_MODE = GPIO_PUSHPULL_OUTPUT;
	pinconfig.GPIO_OUTPUT_SPEED = GPIO_OUTPUT_10MHz;
	pinconfig.GPIO_PIN_NUMBER = GPIO_PIN15;
	MCAL_GPIO_INIT(GPIOB, &pinconfig);



}

void clock_init() {
	//Enable Init Clock GPIOA
	RCC_GPIOA_CLOCK_ENABLE;

	//Enable Init Clock GPIOB
	RCC_GPIOB_CLOCK_ENABLE;

}

void delay_(unsigned int x) {
	volatile int i, j;
	for (i = 0; i < x; i++)
		for (j = 0; j < 255; j++);

}

